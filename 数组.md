原地修改数组
主要思路是：
我们希望经过处理后，数组每个数字都等于它所在的下标，即nums[i] = i + 1。因为有一个数字重重出现两次，一个数据缺失，所以必有一个数字nums[i] != i + 1， nums[i]即为重复的数字，i + 1即为缺失的数字。
那么怎么实现数组每个数组都等于它所在的下标呢：
对于每一个数字nums[i]：移动到nums[nums[i] - 1]。这样，每个数字都可以移动到正确的地方。
nums[i] -> nums[nums[i] - 1] -> nums[nums[nums[i] - 1] - 1]   

寻找数组中的缺失值不能使用直接排序的方法，因为这样无法获得缺失值的下标位置。
在一个数组中寻找几个数的和的话，牵扯到去重（有多个相同的值，所以不去重的话会有重复结果）问题，可以考虑双指针法，但与双指针法结合的必须要先对数组进行排序，之后双指针法才有意义。  

lInkedlist进行插入操作的话，que.add()可以有两个参数，第一个参数为插入位置，第二个参数为插入元素。
前缀和  

求最小删除次数的问题，如果已经得到整个数组不满足条件，必须要删除的话，那求出来删除1次可以满足条件的话，那就直接返回1，因为1肯定是最小删除次数（剪枝）。  

```java
sum += nums[i];
sub_mod = sum % p; 
//上边这样写会越界
sub_mod = (sub_mod + nums[i]) % p; 
target = (sub_mod - mod + p) % p; // 需要的目标前缀和
// 求和的余数的话，这样写可以防止数值越界，每次只加余数的部分
```