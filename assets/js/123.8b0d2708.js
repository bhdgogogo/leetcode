(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{411:function(s,t,n){"use strict";n.r(t);var a=n(4),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("原地修改数组\n主要思路是：\n我们希望经过处理后，数组每个数字都等于它所在的下标，即nums[i] = i + 1。因为有一个数字重重出现两次，一个数据缺失，所以必有一个数字nums[i] != i + 1， nums[i]即为重复的数字，i + 1即为缺失的数字。\n那么怎么实现数组每个数组都等于它所在的下标呢：\n对于每一个数字nums[i]：移动到nums[nums[i] - 1]。这样，每个数字都可以移动到正确的地方。\nnums[i] -> nums[nums[i] - 1] -> nums[nums[nums[i] - 1] - 1]")]),s._v(" "),t("p",[s._v("寻找数组中的缺失值不能使用直接排序的方法，因为这样无法获得缺失值的下标位置。\n在一个数组中寻找几个数的和的话，牵扯到去重（有多个相同的值，所以不去重的话会有重复结果）问题，可以考虑双指针法，但与双指针法结合的必须要先对数组进行排序，之后双指针法才有意义。")]),s._v(" "),t("p",[s._v("lInkedlist进行插入操作的话，que.add()可以有两个参数，第一个参数为插入位置，第二个参数为插入元素。\n前缀和")]),s._v(" "),t("p",[s._v("求最小删除次数的问题，如果已经得到整个数组不满足条件，必须要删除的话，那求出来删除1次可以满足条件的话，那就直接返回1，因为1肯定是最小删除次数（剪枝）。")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[s._v("sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" nums"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nsub_mod "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" sum "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//上边这样写会越界")]),s._v("\nsub_mod "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("sub_mod "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" nums"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \ntarget "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("sub_mod "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" mod "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 需要的目标前缀和")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 求和的余数的话，这样写可以防止数值越界，每次只加余数的部分")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])])])}),[],!1,null,null,null);t.default=e.exports}}]);