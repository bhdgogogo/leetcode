(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{382:function(t,o,l){"use strict";l.r(o);var r=l(4),e=Object(r.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("在循环里，如果想每次循环完一次后都删除集合中的元素，有一种方法，就是可以把集合的初始化放到循环里，即每次都使用了一个新的集，该集合初始化为空")]),t._v(" "),o("p",[t._v("如果终止条件是判断叶子节点，那么递归的过程中就不要让空节点进入递归了。")]),t._v(" "),o("p",[t._v("递归时的终止条件")]),t._v(" "),o("ul",[o("li",[t._v("如果用到了切割的方法，那就要注意边界值的分析。")])]),t._v(" "),o("blockquote",[o("p",[t._v("一般使用左闭右开，那么 left == right 就需要返回了，也就是 left >= right 是返回的一个条件\n通过后序遍历来计算二叉树的后序遍历")])]),t._v(" "),o("p",[t._v("如果问题是需要得到一个二叉树 ，那么递归函数就需要有返回值 —— 分别通过二叉树的左子树和右子树来接收返回值")]),t._v(" "),o("p",[t._v("求最大出现频率（众数），不唯一，如果想要遍历数据结构一次，那就需要定义一个集合，每次当该数的频率大于此时最大频率时，clear 集合，然后再记录，这样就可以保持最大频率一直是最大频率。")]),t._v(" "),o("p",[t._v("如果找到一个符合条件的位置就需要返回时，那该递归函数必须要有返回值，因为要判断该返回值是否为空，如果为空，证明这次递归没找到，如果不为空，则代表找到了符合条件的位置。\n如果题目要求对树进行操作后仍然返回树的根节点，那就可以考虑递归函数有返回值。且用 root.left 和 root.right 接住这个返回值，然后单层进行操作，最后返回 root 结果即可。")])])}),[],!1,null,null,null);o.default=e.exports}}]);